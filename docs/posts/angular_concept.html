<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>angula重要概念 · ShaofeiZi Blog · 做个日常记录</title>
    <meta name="description" content="訾绍飞的博客。万物皆有裂缝处，那是光射进来的地方。">
    <link rel="shortcut icon" href="/BLOG/favicon.ico">
  <link rel="manifest" href="/BLOG/manifest.json">
  <meta name="theme-color" content="#3F51B5">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/BLOG/icons/192.png">
  <link rel="mask-icon" href="/BLOG/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/192.png">
  <meta name="msapplication-TileColor" content="#3F51B5">
    
    <link rel="preload" href="/BLOG/assets/css/45.styles.bc2ae192.css" as="style"><link rel="preload" href="/BLOG/assets/js/app.2cc029fc.js" as="script"><link rel="preload" href="/BLOG/assets/js/38.d93c5cd8.js" as="script"><link rel="prefetch" href="/BLOG/assets/js/8.d5260f8e.js"><link rel="prefetch" href="/BLOG/assets/js/0.35118ea4.js"><link rel="prefetch" href="/BLOG/assets/js/1.e43ae125.js"><link rel="prefetch" href="/BLOG/assets/js/2.65907dcc.js"><link rel="prefetch" href="/BLOG/assets/js/3.9f8eda47.js"><link rel="prefetch" href="/BLOG/assets/js/4.b73a5e88.js"><link rel="prefetch" href="/BLOG/assets/js/5.d5ede685.js"><link rel="prefetch" href="/BLOG/assets/js/6.7721d3b5.js"><link rel="prefetch" href="/BLOG/assets/js/7.ab95dda3.js"><link rel="prefetch" href="/BLOG/assets/js/9.797f9b84.js"><link rel="prefetch" href="/BLOG/assets/js/10.d5faf908.js"><link rel="prefetch" href="/BLOG/assets/js/11.ec46adc5.js"><link rel="prefetch" href="/BLOG/assets/js/12.230ea19d.js"><link rel="prefetch" href="/BLOG/assets/js/13.9df0f3d8.js"><link rel="prefetch" href="/BLOG/assets/js/14.3b2ab513.js"><link rel="prefetch" href="/BLOG/assets/js/15.4f3fa8c1.js"><link rel="prefetch" href="/BLOG/assets/js/16.100984c2.js"><link rel="prefetch" href="/BLOG/assets/js/17.7f43f81f.js"><link rel="prefetch" href="/BLOG/assets/js/18.c32e441e.js"><link rel="prefetch" href="/BLOG/assets/js/19.7e42dc9f.js"><link rel="prefetch" href="/BLOG/assets/js/20.c3bcb4f1.js"><link rel="prefetch" href="/BLOG/assets/js/21.47b9c799.js"><link rel="prefetch" href="/BLOG/assets/js/22.4344faa4.js"><link rel="prefetch" href="/BLOG/assets/js/23.0286b370.js"><link rel="prefetch" href="/BLOG/assets/js/24.b7a8ca7f.js"><link rel="prefetch" href="/BLOG/assets/js/25.65381317.js"><link rel="prefetch" href="/BLOG/assets/js/26.c65897d8.js"><link rel="prefetch" href="/BLOG/assets/js/27.f9d6f503.js"><link rel="prefetch" href="/BLOG/assets/js/28.f070a7bb.js"><link rel="prefetch" href="/BLOG/assets/js/29.676afeef.js"><link rel="prefetch" href="/BLOG/assets/js/30.83c8a398.js"><link rel="prefetch" href="/BLOG/assets/js/31.ebe5983e.js"><link rel="prefetch" href="/BLOG/assets/js/32.2daa45c8.js"><link rel="prefetch" href="/BLOG/assets/js/33.c7cd4d75.js"><link rel="prefetch" href="/BLOG/assets/js/34.57763f4b.js"><link rel="prefetch" href="/BLOG/assets/js/35.226a9690.js"><link rel="prefetch" href="/BLOG/assets/js/36.5c71fdf4.js"><link rel="prefetch" href="/BLOG/assets/js/37.28820586.js"><link rel="prefetch" href="/BLOG/assets/js/39.63c34eed.js"><link rel="prefetch" href="/BLOG/assets/js/40.f050a9d5.js"><link rel="prefetch" href="/BLOG/assets/js/41.5f1d6d77.js"><link rel="prefetch" href="/BLOG/assets/js/42.6de5489d.js"><link rel="prefetch" href="/BLOG/assets/js/43.5b60c0a8.js"><link rel="prefetch" href="/BLOG/assets/js/44.5fc1ef91.js">
    <link rel="stylesheet" href="/BLOG/assets/css/45.styles.bc2ae192.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="application theme--light"><div class="application--wrap"><div class="progress-linear blog-progress" style="height:3px;display:none;"><div class="progress-linear__background accent" style="height:3px;opacity:0.4;width:100%;"></div><div class="progress-linear__bar"><!----><div class="progress-linear__bar__determinate accent" style="width:0%;"></div></div></div><aside class="navigation-drawer navigation-drawer--close navigation-drawer--fixed navigation-drawer--is-mobile" style="height:100%;margin-top:0px;max-height:calc(100% - 0px);transform:translateX(-240px);width:240px;"><div><div class="aside-brand-wrap"><div class="aside-brand"><a href="/BLOG/" class="aside-avatar elevation-2 router-link-active"><img src="/BLOG/face.png" alt="avatar"></a><hgroup class="mt-3 variant-hide"><div class="subheading white--text">訾绍飞</div><a href="mailto:zishaofei221@gmail.com" title="zishaofei221@gmail.com" class="aside-mail primary--text text--lighten-5">zishaofei221@gmail.com</a></hgroup></div></div><hr class="divider theme--dark"><div class="list nav-list"><div class="secondary--text"><a href="/BLOG/" class="list__tile list__tile--link"><div class="list__tile__avatar"><div class="avatar" style="height:40px;width:40px;"><i class="fa fa-home"></i></div></div><div class="list__tile__content">首页</div></a></div><div class="secondary--text"><a href="/BLOG/tags" class="list__tile list__tile--link"><div class="list__tile__avatar"><div class="avatar" style="height:40px;width:40px;"><i class="fa fa-tag"></i></div></div><div class="list__tile__content">标签</div></a></div><div class="secondary--text"><a href="https://github.com/ShaofeiZi" target="_blank" class="list__tile list__tile--link"><div class="list__tile__avatar"><div class="avatar" style="height:40px;width:40px;"><i class="fab fa-github"></i></div></div><div class="list__tile__content">Github</div></a></div><div class="secondary--text"><a href="/BLOG/about" class="list__tile list__tile--link"><div class="list__tile__avatar"><div class="avatar" style="height:40px;width:40px;"><i class="fa fa-user-secret"></i></div></div><div class="list__tile__content">About</div></a></div></div></div><div class="navigation-drawer__border"></div></aside><nav class="blog-toolbar toolbar toolbar--fixed theme--dark primary" style="margin-top:0px;padding-right:0px;padding-left:0px;transform:translateY(0px);"><div class="toolbar__content" style="height:56px;"><button type="button" class="btn btn--icon"><div class="btn__content"><i class="fa fa-bars"></i></div></button><div class="toolbar__title">angula重要概念</div><div class="spacer"></div><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><div class="menu" style="display:none;"><div class="menu__activator"><button type="button" class="btn btn--icon"><div class="btn__content"><i class="fa fa-share-alt"></i></div></button></div><div class="menu__content" style="max-height:auto;min-width:0px;max-width:auto;top:12px;left:0px;transform-origin:top right;z-index:0;display:none;"><div class="list"><div class="secondary--text"><a class="list__tile list__tile--link"><div class="list__tile__avatar"><div class="avatar" style="height:40px;width:40px;"><i class="fa fa-lg fa-copy"></i></div></div><div class="list__tile__title">复制链接</div></a></div></div><input type="text" tabindex="-1" aria-hidden="true" value="" class="fake-hide"></div></div></div></nav><main class="content" style="padding-top:56px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="content--wrap"><div class="container blog-container grid-list-xl align-center"><div class="layout row wrap"><div class="flex mb-3 xs12"><article class="card elevation-16 post-card" style="height:auto;"><div class="card__title"><div class="flex xs12"><h2 class="display-1 mb-3">angula重要概念</h2><div class="post-meta"><time datetime="2018-07-01T12:15:53.000Z" class="secondary--text post-time">2018年07月01日</time></div></div></div><div class="card__text pt-0 pb-0"><div class="flex xs12"><div class="content custom"><h1 id="angular概念"><a href="#angular概念" aria-hidden="true" class="header-anchor">#</a> Angular概念</h1><p><img src="/images/angular_concept/001.png" alt></p><p><img src="/images/angular_concept/002.png" alt></p><p><strong>不能把Angular当作黑盒来使用,要充分了解它的内部结构。</strong></p><h2 id="依赖注入"><a href="#依赖注入" aria-hidden="true" class="header-anchor">#</a> 依赖注入</h2><p>1、 什么是依赖注入？</p><p>2、依赖性注入框架</p><p>Angular</p><p><img src="/images/angular_concept/003.png" alt></p><p>在angular中，我们只要记住依赖注入的三种角色：<strong>使用者、服务(依赖对象)及注入器(Injector)</strong></p><ul><li><p>** @Injectable是@Component的子类**</p></li><li><p>每一个HTML标签上面都会有一个注射器实例</p></li><li><p>注射是通过constructor(构造器)进行的</p></li></ul><p><img src="/images/angular_concept/004.jpg" alt></p><p><strong>注入器(Injectable)和提供器(Provider)</strong></p><p><img src="/images/angular_concept/005.png" alt></p><p>3、依赖性注入进阶</p><p><strong>什么时候使用装饰器：@Injectable( )</strong></p><p><strong>当创建服务（service）需要在构造函数中注入依赖对象，就需要使用 Injectable 装饰器。</strong></p><p>延伸1：@Injectable() 是必须的么？</p><p>如果所创建的服务不依赖于其他对象，是可以不用使用 <code>Injectable</code> 类装饰器。但当该服务需要在构造函数中注入依赖对象，就需要使用 Injectable 装饰器。不过比较推荐的做法不管是否有依赖对象，在创建服务时都使用 <code>Injectable 类装饰器</code>。</p><p>延伸2：注入器的层级关系( 服务之间如何之间注入 )</p><ul><li>提供器可以声明在模块中，也可以声明在组件中。</li><li>在angular中只有一种注入，那就是构造器注入。如发现无参构造器，这就说明这个组件没有被注入任何东西。</li></ul><h2 id="changedeteccion"><a href="#changedeteccion" aria-hidden="true" class="header-anchor">#</a> ChangeDeteccion</h2><p>检测程序内部状态，然后反映到UI上</p><p>引起状态变化(异步)：</p><ul><li>Events</li><li>XHR</li><li>Times</li></ul><h2 id="指令"><a href="#指令" aria-hidden="true" class="header-anchor">#</a> 指令</h2><p>组件是一种特殊的指令（组件是一种带模板的指令）</p><ul><li>结构型指令  --改变元素的布局</li><li>属性型指令  --改变外观和行为</li></ul><blockquote><p>属性型指令</p></blockquote><p>Renderer 2 和 ElementRef</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li>Angular 不提倡直接操作DOM</li><li>对于DOM的操作应该通过Renderer 2来进行</li><li>ElementRef 可以理解成指向DOM元素的引用</li></ul></div><blockquote><p>结构型指令</p></blockquote><p><img src="/images/angular_concept/006.png" alt></p><blockquote><p>样式</p></blockquote><p><strong>ngClass，ngStyle，[class.yourstyle]</strong></p><p>ngClass： 用于条件动态指定样式类，适合对样式做大量更改的情况</p><p>ngStyle： 用于条件动态指定样式，适合少量更改的情况</p><p>[class.yourcondition]=&quot;condition&quot; : 直接对应一个条件</p><h3 id="延伸1-ng-template-与-ng-container-有什么区别？"><a href="#延伸1-ng-template-与-ng-container-有什么区别？" aria-hidden="true" class="header-anchor">#</a> 延伸1: <strong><code>&lt;ng-template&gt;</code><strong>与</strong><code>&lt;ng-container&gt;</code></strong> 有什么区别？</h3><p><strong><code>&lt;ng-template&gt;</code></strong> 用于定义模板，使用 <code>*</code> 语法糖的结构指令，最终都会转换为 <code>&lt;ng-template&gt;</code> 模板指令，模板内的内容如果不进行处理，是不会在页面中显示</p><p><code>&lt;ng-container&gt;</code> 是一个逻辑容器，可用于对节点进行分组，但不作为 DOM 树中的节点，它将被渲染为 HTML中的 <code>comment</code> 元素，它可用于避免添加额外的元素来使用结构指令。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>ng-container</code>既不是一个Component，也不是一个Directive，只是单纯的一个特殊tag。</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这点类似于template，Angular复用了HTML5规范中template 的tag的语义，不过并没有真正利用其实现，因此在审查元素中是永远也找不到一个template元素的。
不过，由于ng-container并不是HTML5中的，为了保持区分度，采用了ng-作为前缀。所以现在我们可以知道，ng-container是Angular所定义的一个特殊tag。</p></div><h3 id="延伸2：不要混淆-ng-container-与-ng-content"><a href="#延伸2：不要混淆-ng-container-与-ng-content" aria-hidden="true" class="header-anchor">#</a> 延伸2：不要混淆 <code>ng-container</code> 与 <code>ng-content</code></h3><p><strong><code>ng-content</code></strong> 是一个占位符，有些类似于<code>router-outlet</code></p><p><strong>拓展1：</strong>  那为什么要是使用<code>ng-content</code>？什么场景使用呢？</p><p>答： 父组件包含子组件都是直接指明子组件的<code>selector</code>，比如子组件的<code>selector</code>叫<code>app-child</code>，那么嵌入父组件时直接指明即可:<strong><code>&lt;app-child&gt;&lt;/app-child&gt;</code></strong></p><p>这是很硬性的编码，而<code>ng-content</code>就是用来替代这种硬性编码的。</p><h3 id="延伸3：-templateref-与-viewcontainerref-有什么作用？"><a href="#延伸3：-templateref-与-viewcontainerref-有什么作用？" aria-hidden="true" class="header-anchor">#</a> 延伸3： <code>TemplateRef</code> 与 <code>ViewContainerRef</code> 有什么作用？</h3><ul><li><p>TemplateRef：用于表示内嵌的 template 模板元素，通过 TemplateRef 实例，我们可以方便创建内嵌视图(Embedded Views)，且可以轻松地访问到通过 ElementRef 封装后的 nativeElement。需要注意的是组件视图中的 template 模板元素，经过渲染后会被替换成 comment 元素。</p></li><li><p>ViewContainerRef：用于表示一个视图容器，可添加一个或多个视图。通过 ViewContainer
Ref 实例，我们可以基于 TemplateRef 实例创建内嵌视图，并能指定内嵌视图的插入位置，也可以方便对视图容器中已有的视图进行管理。简而言之，ViewContainerRef 的主要作用是创建和管理内嵌视图或组件视图。</p></li></ul><h3 id="延伸4：-viewchild和viewchildren"><a href="#延伸4：-viewchild和viewchildren" aria-hidden="true" class="header-anchor">#</a> 延伸4： <code>ViewChild</code>和<code>ViewChildren</code></h3><p><strong>ViewChild</strong> 该装饰器用于获取模板视图中的元素或直接调用其组件中的方法。它支持 Type 类型或 string 类型的选择器，同时支持设置 read 查询条件，以获取不同类型的实例。比如<code>ElementRef</code>和<code>ViewContainerRef</code>.</p><p><strong>ViewChildren</strong> 该装饰器是用来从模板视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合。</p><p><img src="/images/angular_concept/007.png" alt></p><h3 id="通信"><a href="#通信" aria-hidden="true" class="header-anchor">#</a> 通信</h3><ul><li><p>父子组件通信</p><ul><li>父子组件通信一般使用@Input和@Output即可实现.</li><li>通过Subject</li></ul></li><li><p>非父子组件通信</p><ul><li>非父子组件见通信可以通过同一个service来实现。需要注意的是一定要在service中<strong>定义一个临时变量来供传递</strong></li></ul></li></ul><h2 id="模块"><a href="#模块" aria-hidden="true" class="header-anchor">#</a> 模块</h2><p>什么是模块？</p><p><strong>declarations:</strong> 模块内部<code>Components/Directives/Pipes</code>的列表，声明一下这个模块内部成员(<strong>本模块创建的组件，加入到这个元数据中的组件才会被编译</strong>)</p><p><strong>imports：</strong> 导入<strong>其他module</strong>，其它module暴露的出的Components、Directives、Pipes等可以在本module的组件中被使用。比如导入CommonModule后就可以使用NgIf、NgFor等指令。(<strong>引入的外部NG模块</strong>)</p><p><strong>exports：</strong> 用来控制将哪些内部成员暴露给外部使用。导入一个module并不意味着会自动导入这个module内部导入的module所暴露出的公共成员。除非导入的这个module把它内部导入的module写到exports中。</p><p><img src="/images/angular_concept/008.png" alt></p><p><strong>providers：</strong> 指定应用程序的根级别需要使用的service。（Angular2中没有模块级别的service，所有在NgModule中声明的Provider都是注册在根级别的Dependency Injector中）</p><p><strong>bootstrap：</strong> 通常是app启动的根组件，一般只有一个component。bootstrap中的组件会自动被放入到entryComponents中。(<strong>声明启动引导哪个组件，必须是编译过的组件</strong>)</p><p>需要强调的是，<code>bootstrap</code>元数据声明的组件必须是编译过的组件：它要么属于 使用<code>imports</code>元数据引入的外部NG模块，要么是已经在<code>declarations</code>元数据 中声明的本地组件。</p><p><strong>entryCompoenents:</strong> 不会再模板中被引用到的组件。这个属性一般情况下只有ng自己使用，一般是bootstrap组件或者路由组件，ng会自动把bootstrap、路由组件放入其中。 除非不通过路由动态将component加入到dom中，否则不会用到这个属性。</p><p><strong>模块的元数据？</strong></p><p><code>@NgModule</code>元数据告诉Angular编译器要为当前模块编译哪些组件，以及如何把当前模块和其它模块链接起来。</p><p><strong>经常看到的<code>forRoot()</code>是什么鬼？</strong></p><p>静态方法forRoot是一个约定，它可以让开发人员更轻松的配置模块的提供商。</p><p><code>RouterModule.forRoot</code>就是一个很好的例子。 应用把一个Routes对象传给<code>RouterModule.forRoot</code>，为的就是使用路由配置全应用级的Router服务。 <code>RouterModule.forRoot</code>返回一个<code>ModuleWithProviders</code>对象。 我们把这个结果添加到根模块AppModule的imports列表中。</p><p>只能在应用的根模块AppModule中调用并导入.forRoot的结果。 在其它模块中导入它，特别是惰性加载模块中，是违反设计目标的并会导致一个运行时错误。</p><p>RouterModule也提供了静态方法forChild，用于配置惰性加载模块的路由。</p><p>forRoot和forChild都是方法的约定名称，它们分别用于在根模块和特性模块中配置服务。</p><p>Angular并不识别这些名字，但是Angular的开发人员可以。 当你写类似的需要可配置的服务提供商时，请遵循这个约定。</p><h2 id="模板型驱动表单-和-响应式表单"><a href="#模板型驱动表单-和-响应式表单" aria-hidden="true" class="header-anchor">#</a> 模板型驱动表单 和 响应式表单</h2><ul><li>模板型驱动表单</li></ul><p><strong>特点</strong></p><p>1、表单的数据绑定(例如ngModel的双向绑定)
2、ngModel的困惑</p><ul><li>响应式表单</li></ul><p><strong>三个重要元素：</strong></p><ul><li>FormControl</li><li>FormGroup</li><li>FormBuilder</li></ul><h2 id="路由"><a href="#路由" aria-hidden="true" class="header-anchor">#</a> 路由</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:right">简介</th></tr></thead><tbody><tr><td style="text-align:left">Routes</td><td style="text-align:right">路由配置，保存着那个URL对应展示哪个组件，以及在哪个RouterOutlet中展示组件</td></tr><tr><td style="text-align:left">RouterOutlet</td><td style="text-align:right">在Html中标记路由呈现位置的占位符指令</td></tr><tr><td style="text-align:left">Router</td><td style="text-align:right">负责在运行时执行路由的对象，可以通过调用器navigate() 和navigateByUrl()方法来导航到一个指定的路由</td></tr><tr><td style="text-align:left">RouterLink</td><td style="text-align:right">在Html中声明路由导航用的指令</td></tr><tr><td style="text-align:left">ActivedRoute</td><td style="text-align:right">当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等</td></tr></tbody></table><p>** Routes **  其实是一个Route类的数组。</p><p><img src="/images/angular_concept/009.png" alt></p><p>而<code>Route</code>的参数如下图所示，一般情况下，<code>path</code>和<code>component</code>是必选的两个参数。比如：<code>path:/a</code>,<code>component:A</code>则说明，当地址为<code>/a</code>时，应该展示组件<code>A</code>的内容。</p><p><img src="/images/angular_concept/010.png" alt></p><p><strong>其余类的简介见下图：</strong></p><p><img src="/images/angular_concept/011.png" alt></p><h3 id="延伸1：-路由参数传递-参数传递的几种方式"><a href="#延伸1：-路由参数传递-参数传递的几种方式" aria-hidden="true" class="header-anchor">#</a> 延伸1： 路由参数传递 -- 参数传递的几种方式</h3><ul><li>普通方式传递数据：<code>/product?id=1&amp;name=iphone =&gt; ActivatedRoute.queryParams[id]</code>;</li><li>rest方式传递数据：<code>{path:/product/:id} =&gt; /product/1 =&gt; ActivatedRoute.params[id];</code></li><li>路由配置传递数据：<code>{path:/product,component:ProductComponent,data:[{madeInChina:true}]} =&gt; ActivatedRoute.data[0][madeInChina];</code></li></ul><h2 id="数据绑定、响应式编程和管道、-input-与-output"><a href="#数据绑定、响应式编程和管道、-input-与-output" aria-hidden="true" class="header-anchor">#</a> 数据绑定、响应式编程和管道、@Input()与@Output()</h2><blockquote><p>数据绑定: Angular中的数据绑定指的是同一组件中**控制器文件(.ts)<strong>与</strong>视图文件(.html)**之间的数据传递。</p></blockquote><ul><li>单向绑定： 它的意思是要么是ts文件为html文件赋值，要么相反。</li></ul><p><img src="/images/angular_concept/012.png" alt></p><p><img src="/images/angular_concept/013.png" alt></p><ul><li>双向绑定: ts文件与html文件中绑定的值同时改变。</li></ul><p><img src="/images/angular_concept/014.png" alt></p><h4 id="dom属性和html属性"><a href="#dom属性和html属性" aria-hidden="true" class="header-anchor">#</a> DOM属性和HTML属性</h4><ul><li><p>1、少量 HTML 属性 和 DOM 属性之间有着1:1的映射，如id。(<strong>HTML元素属性和DOM属性的名称和值大部分都相同</strong>)</p></li><li><p>2、有些HTML属性没有对应的DOM属性，如 colspan</p></li><li><p>3、有些DOM属性没有对应的HTML属性，如textContent。有些名字相同，HTML属性和DOM属性的值也不是同一样东西。</p></li><li><p>4、HTML属性的值指定了初始值；DOM属性的值标识当前值。<strong>DOM属性的值可以改变；HTML属性的值不能改变。</strong></p></li><li><p>5、模板绑定是通过DOM属性和时间来工作的，而不是 HTML 属性。</p></li></ul><h3 id="dom属性绑定"><a href="#dom属性绑定" aria-hidden="true" class="header-anchor">#</a> DOM属性绑定</h3><p><img src="/images/angular_concept/015.png" alt></p><h3 id="html属性绑定"><a href="#html属性绑定" aria-hidden="true" class="header-anchor">#</a> HTML属性绑定</h3><p><img src="/images/angular_concept/016.png" alt></p><p><strong>DOM绑定与HTML属性绑定的区别</strong></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">DOM绑定</th><th style="text-align:center">HTML绑定</th></tr></thead><tbody><tr><td style="text-align:left">相同情况下</td><td style="text-align:right">一个元素的id</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">有html属性无dom属性</td><td style="text-align:right"></td><td style="text-align:center">表格中td的colspan</td></tr><tr><td style="text-align:left">有dom属性无html属性</td><td style="text-align:right">textContent属性</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">关于值</td><td style="text-align:right">dom表示当前值</td><td style="text-align:center">html表示初始化值</td></tr><tr><td style="text-align:left">关于可变</td><td style="text-align:right">dom值是可变的</td><td style="text-align:center">html值是不可变的</td></tr></tbody></table><blockquote><p>总结:我们模板绑定是通过DOM属性来操作的，不是HTML属性来操作的</p></blockquote><h3 id="类绑定"><a href="#类绑定" aria-hidden="true" class="header-anchor">#</a> 类绑定</h3><p><img src="/images/angular_concept/017.png" alt></p><h3 id="样式绑定"><a href="#样式绑定" aria-hidden="true" class="header-anchor">#</a> 样式绑定</h3><p><img src="/images/angular_concept/018.png" alt></p><h4 id="模板变量"><a href="#模板变量" aria-hidden="true" class="header-anchor">#</a> 模板变量</h4><p><img src="/images/angular_concept/019.png" alt></p><h5 id="angular中的输入输出是通过注解-input和-output来标识，它位于组件控制器的属性上方。输入输出针对的对象是父子组件。"><a href="#angular中的输入输出是通过注解-input和-output来标识，它位于组件控制器的属性上方。输入输出针对的对象是父子组件。" aria-hidden="true" class="header-anchor">#</a> Angular中的输入输出是通过注解<code>@Input</code>和<code>@Output</code>来标识，它位于组件控制器的属性上方。<strong>输入输出针对的对象是父子组件</strong>。</h5><h2 id="rxjs"><a href="#rxjs" aria-hidden="true" class="header-anchor">#</a> RxJS</h2><h2 id="redux"><a href="#redux" aria-hidden="true" class="header-anchor">#</a> Redux</h2><p>1、Redux 是什么？</p><p>全局的、唯一的、不可变的内存状态[数据库]</p><p><img src="/images/angular_concept/020.png" alt></p><h2 id="angular-整合redux"><a href="#angular-整合redux" aria-hidden="true" class="header-anchor">#</a> Angular 整合Redux</h2><h4 id="导入ngredux"><a href="#导入ngredux" aria-hidden="true" class="header-anchor">#</a> 导入NgRedux</h4><p><img src="/images/angular_concept/021.png" alt></p><h4 id="构造参数为store的构造器"><a href="#构造参数为store的构造器" aria-hidden="true" class="header-anchor">#</a> 构造参数为<code>store</code>的构造器</h4><p><img src="/images/angular_concept/022.png" alt></p><h4 id="在你的组件-components-中使用store"><a href="#在你的组件-components-中使用store" aria-hidden="true" class="header-anchor">#</a> 在你的组件(components)中使用<code>store</code></h4><p><img src="/images/angular_concept/023.png" alt></p><h4 id="注入actions"><a href="#注入actions" aria-hidden="true" class="header-anchor">#</a> 注入Actions</h4><p><img src="/images/angular_concept/024.png" alt></p><h4 id="accessing-访问-services-from-actions"><a href="#accessing-访问-services-from-actions" aria-hidden="true" class="header-anchor">#</a> Accessing(访问) Services from Actions</h4><p><img src="/images/angular_concept/025.png" alt></p><h4 id="dispatching-调度、派遣-actions"><a href="#dispatching-调度、派遣-actions" aria-hidden="true" class="header-anchor">#</a> Dispatching(调度、派遣) Actions</h4><p><img src="/images/angular_concept/026.png" alt></p><h2 id="目前angular整合redux两种方式："><a href="#目前angular整合redux两种方式：" aria-hidden="true" class="header-anchor">#</a> 目前Angular整合Redux两种方式：</h2><ul><li><p><code>Ng-redux</code> 核心仍使用 Redux，增加對 Angular 的支援</p></li><li><p><code>Ngrx</code> 只有概念使用 Redux，核心完全使用 RxJS 重新操作。</p></li></ul><p><strong>安裝 Ngrx</strong></p><pre class="language-text"><code>npm install @ngrx/core @ngrx/store --save
</code></pre><p><img src="/images/angular_concept/027.png" alt></p><p><img src="/images/angular_concept/028.gif" alt></p><p><strong>View</strong> 相当于<code>component</code>，主要在显示使用者界面。</p><p><strong>Action</strong> 当<code>component</code> 有任何 <code>event</code> 時，会对 <code>Ngrx</code> 发出 <code>action</code>。</p><p><strong>Middleware</strong> 负责存取对 <code>server</code> 端的 API</p><p><strong>Dispatcher</strong> 负责接受 <code>component</code> 传来的 action，并将 <code>action</code> 传给 <code>reducer</code>。</p><p><strong>Store</strong> 可是为 <code>Ngrx</code> 在浏览器端的资料库，各 <code>component</code> 的资料都可统一放在这里。</p><p><strong>Reducer</strong> 根据<code>dispatcher</code> 传来的 <code>action</code>，决定该如何写入state。</p><p>当 <code>state</code> 有改变时，將通知有<code>subscribe</code>该<code>state</code>的<code>component</code>自动更新。</p><p><strong>State</strong> 存放在 <code>store</code> 內的资料。</p><p><img src="/images/angular_concept/029.svg" alt></p><p>有些东西Ngrx 已经帮我们做了，真的要我们自己操作只有 4 个部份，且资料流为单向的 : <code>Component -&gt; Action -&gt; Reducer -&gt; Store -&gt; Component</code>。</p><h3 id="什么时候该使用ngrx？"><a href="#什么时候该使用ngrx？" aria-hidden="true" class="header-anchor">#</a> 什么时候该使用Ngrx？</h3><ul><li>当多个 <code>component</code> 需使用共用资料，且各 <code>component</code> 的操作会影像其他 <code>component</code> 的结果。</li><li>资料可能同时被多个<code>component</code>修改，甚至同時被 <code>server API</code>修改。</li><li>需要操作undo/redo 功能。</li></ul><blockquote><p>案例--操作：</p></blockquote><p><a href="https://github.com/ngrx/platform/blob/master/MIGRATION.md" target="_blank" rel="noopener noreferrer">新版迁移指南 ：https://github.com/ngrx/platform/blob/master/MIGRATION.md</a></p><p><strong>AppModule：app.module.ts</strong></p><p><img src="/images/angular_concept/030.png" alt></p><p><strong>AppComponent ：--&gt; app.component.html、app.component.ts</strong></p><p><img src="/images/angular_concept/031.png" alt></p><p><strong>Action ：--&gt; counter.action.ts</strong></p><p><img src="/images/angular_concept/032.png" alt></p><p><strong>Reducer ：--&gt; counter.reducer.ts</strong></p><p><img src="/images/angular_concept/033.png" alt></p><p><strong>Store ：--&gt; counter.store.ts</strong></p><p><img src="/images/angular_concept/034.png" alt></p><h3 id="redux-在您的angular应用使用reselect进行状态函数的高阶运算"><a href="#redux-在您的angular应用使用reselect进行状态函数的高阶运算" aria-hidden="true" class="header-anchor">#</a> Redux 在您的Angular应用使用<code>reselect</code>进行状态函数的高阶运算</h3><p>reselect：带‘记忆’功能的函数运算</p><p>无论多少参数，最后一个才是用于函数计算，其他的都是他的输入</p><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> getTasksWithOwner <span class="token operator">=</span> <span class="token function">createSelector</span><span class="token punctuation">(</span>getTasks<span class="token punctuation">,</span>getUserEntities<span class="token punctuation">,</span><span class="token punctuation">(</span>tasks<span class="token punctuation">,</span>entities<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> tasks<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>task <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> owner <span class="token operator">=</span> entites<span class="token punctuation">[</span>task<span class="token punctuation">.</span>ownerId<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> participants <span class="token operator">=</span>task<span class="token punctuation">.</span>participantIds<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>id <span class="token operator">=&gt;</span> entites<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assgin</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>task<span class="token punctuation">,</span><span class="token punctuation">{</span>owner<span class="token punctuation">:</span>owner<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>participants<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token operator">...</span>participants<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h2 id="使用-ngrx-store"><a href="#使用-ngrx-store" aria-hidden="true" class="header-anchor">#</a> 使用<code>@ngrx/store</code></h2><p><img src="/images/angular_concept/035.png" alt></p><p><strong>Registering Reducers</strong><img src="/images/angular_concept/036.png" alt></p><p>简化：
<img src="/images/angular_concept/037.png" alt></p><p>示例：
<img src="/images/angular_concept/038.png" alt></p><h2 id="什么是effect"><a href="#什么是effect" aria-hidden="true" class="header-anchor">#</a> 什么是Effect?</h2><p><code>@Effect()</code> 标识是一个<code>Observable&lt;Action&gt;</code>流。</p><p><img src="/images/angular_concept/039.png" alt></p><p><img src="/images/angular_concept/040.png" alt></p><p><img src="/images/angular_concept/041.png" alt></p><p><strong>使用effect：<code>import {Actions, Effect} from '@ngrx/effects';</code></strong></p><pre class="language-typescript"><code>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthEffects</span><span class="token punctuation">{</span>
  <span class="token comment">// 通过构造注入需要的服务和 action 信号流</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> actions$<span class="token punctuation">:</span> Actions<span class="token punctuation">,</span> <span class="token keyword">private</span> authService<span class="token punctuation">:</span> AuthService<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  
  <span class="token comment">//用 @Effect() 修饰器来标明这是一个 Effect</span>
  @<span class="token function">Effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  login$<span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span>Action<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>actions$ <span class="token comment">// action 信号流</span>
    <span class="token punctuation">.</span><span class="token function">ofType</span><span class="token punctuation">(</span>authActions<span class="token punctuation">.</span>ActionTypes<span class="token punctuation">.</span><span class="token constant">LOGIN</span><span class="token punctuation">)</span> <span class="token comment">// 如果是 LOGIN Action</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toPayload<span class="token punctuation">)</span> <span class="token comment">// 转换成 action 的 payload 数据流</span>
    <span class="token punctuation">.</span><span class="token function">switchMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">:</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span><span class="token builtin">string</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 调用服务</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authService
          <span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span>username<span class="token punctuation">,</span> val<span class="token punctuation">.</span>password<span class="token punctuation">)</span>
          <span class="token comment">// 如果成功发出 LOGIN_SUCCESS Action 交给其它 Effect 或者 Reducer 去处理</span>
          <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>user <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">authActions<span class="token punctuation">.</span>LoginSuccessAction</span><span class="token punctuation">(</span><span class="token punctuation">{</span>user<span class="token punctuation">:</span> user<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token comment">// 如果失败发出 LOGIN_FAIL Action 交给其它 Effect 或者 Reducer 去处理</span>
          <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">actions<span class="token punctuation">.</span>LoginFailAction</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><p>顺序安装依赖库</p><pre class="language-typescript"><code>$ npm i <span class="token operator">--</span>save @ngrx<span class="token operator">/</span>core
$ npm i <span class="token operator">--</span>save @ngrx<span class="token operator">/</span>store
$ npm i <span class="token operator">--</span>save @ngrx<span class="token operator">/</span>effects

<span class="token comment">/**
 * 我们使用reselect来实现高效的`state`存取操作。我们将使用`reselect`的
 * `createSelector`方法来创建高效的选择器，这个选择器能被存储且仅在参
 * 数更改的时候才会重构
 */</span>
$ npm i <span class="token operator">--</span>save reselect
 
 <span class="token comment">/**
  * 为了让开发更加方便并易于调试，我们添加能够在控制台记
  * 录action和state的更新的store-logger来帮助我们
  */</span>
$ npm i <span class="token operator">--</span>save ngrx<span class="token operator">-</span>store<span class="token operator">-</span>logger 
</code></pre><p>示例：
<img src="/images/angular_concept/042.png" alt></p><h2 id="使用-ngrx-router-store"><a href="#使用-ngrx-router-store" aria-hidden="true" class="header-anchor">#</a> 使用<code>@ngrx/router-store</code></h2><p><img src="/images/angular_concept/043.png" alt></p><h3 id="navigation-actions"><a href="#navigation-actions" aria-hidden="true" class="header-anchor">#</a><strong>Navigation actions</strong></h3><p><img src="/images/angular_concept/044.png" alt></p><p>示例：
<img src="/images/angular_concept/045.png" alt></p><h2 id="使用-ngrx-store-devtools"><a href="#使用-ngrx-store-devtools" aria-hidden="true" class="header-anchor">#</a> 使用<code>@ngrx/store-devtools</code></h2><p>注册到模块中</p><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> StoreDevtoolsModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@ngrx/store-devtools'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> environment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../environments/environment'</span><span class="token punctuation">;</span> <span class="token comment">// Angular CLI environment</span>

@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token operator">!</span>environment<span class="token punctuation">.</span>production <span class="token operator">?</span> StoreDevtoolsModule<span class="token punctuation">.</span><span class="token function">instrument</span><span class="token punctuation">(</span><span class="token punctuation">{</span> maxAge<span class="token punctuation">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><h2 id="常出现的异常解决方案"><a href="#常出现的异常解决方案" aria-hidden="true" class="header-anchor">#</a> 常出现的异常解决方案</h2><p>1、多次声明同一个组件</p><p>组件是 Angular 应用程序中的常见构建块。每个组件都需要在** <code>@NgModule.declarations</code>** 数组中声明，才能够使用。在 Angular 中是不允许在多个模块中声明同一个组件，如果一个组件在多个模块中声明的话，那么 Angular 编译器将会抛出异常。</p><blockquote><p>场景使用 -- 在多个模块中使用同一个组件是允许的</p></blockquote><ul><li><p>如果一个模块作为另一个模块的子模块，那么针对上面的场景解决方案将是：</p><ul><li>在子模块的 ** @NgModule.declaration ** 中声 <strong>HeroComponent</strong> 组件</li><li>通过子模块的** @NgModule.exports **数组中导出该组件</li><li>在父模块的 ** @NgModule.imports **数组中导入子模块</li></ul></li><li><p>对于其它情况，我们可以创建一个新的模块(共享模块)，如** SharedModule** 模块。具体步骤如下：</p><ul><li>在 <strong>SharedModule</strong> 中声明和导出 <strong>HeroComponent</strong></li><li>在需要使用 <strong>HeroComponent</strong> 的模块中导入** SharedModule**</li></ul></li></ul><p>2、<strong>angular: Error: Uncaught (in promise): Error: StaticInjectorError...</strong></p><p>原因：构建的service没有添加到module里造成的 或者 service module没有在app 的module下引入。</p><p>3、<strong>core.js:1350 ERROR Error: Uncaught (in promise): Error: StaticInjectorError[Http]: StaticInjectorError[Http]: NullInjectorError: No provider for Http!</strong></p><p>将HttpMoudle导入到我的app.module.ts中，问题就没有了</p><pre class="language-text"><code>import { HttpModule } from '@angular/http';
</code></pre></div></div></div><div class="card__actions"><div class="flex xs12"><a href="/BLOG/tags/RXJS"><span tabindex="0" class="chip capitalize chip-tag chip--label chip--small"><span class="chip__content">RXJS</span></span></a><a href="/BLOG/tags/angular"><span tabindex="0" class="chip capitalize chip-tag chip--label chip--small"><span class="chip__content">angular</span></span></a></div></div></article></div><div class="flex text-xs-left xs6"><a href="/BLOG/posts/VueaddRXJS.html" class="post-nav btn btn--flat btn--router"><div class="btn__content"><div class="grey--text"><i class="fa mr-1 fa-chevron-left"></i>Prev</div><div class="title mt-1 primary--text hidden-xs-only">RxJS实践，Vue如何集成RxJS</div></div></a></div><div class="flex text-xs-right xs6"><a href="/BLOG/posts/rxjs29.html" class="post-nav btn btn--flat btn--router"><div class="btn__content"><div class="grey--text">Next
          <i class="fa ml-1 fa-chevron-right"></i></div><div class="title mt-1 primary--text hidden-xs-only">29 三十天感言</div></div></a></div><div class="flex mt-3 xs12"><div class="card" style="height:auto;"><div class="card__title"><span class="headline">Comment</span></div></div></div></div></div><footer class="footer blog-footer darken-1 mt-3 theme--dark" style="height:auto;"><div class="primary--text text--lighten-4 text-xs-center py-3 card card--flat card--tile primary" style="height:auto;"><div class="card__text pb-0">博客内容遵循 <a rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div><div class="card__text pt-0 mt-1"><span>訾绍飞 © 2015 - 2018</span><span><!---->
        Power by
        <a href="https://vuepress.vuejs.org" target="_blank" rel="noopener noreferrer">VuePress</a> Theme
        <a href="https://github.com/ShaofeiZi/BLOG" target="_blank" rel="noopener noreferrer">indigo</a></span></div></div></footer></div></main><button type="button" class="btn btn--bottom btn--floating btn--fixed btn--right accent" style="display:none;"><div class="btn__content"><i class="fa fa-lg fa-chevron-up"></i></div></button></div></div></div>
    <script src="/BLOG/assets/js/38.d93c5cd8.js" defer></script><script src="/BLOG/assets/js/app.2cc029fc.js" defer></script>
  </body>
</html>
