(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{232:function(t,a,n){"use strict";n.r(a);var e=n(1),r=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"_30-天精通-rxjs-01-：认识-rxjs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_30-天精通-rxjs-01-：认识-rxjs","aria-hidden":"true"}},[t._v("#")]),t._v(" 30 天精通 RxJS (01)：认识 RxJS")]),n("blockquote",[n("p",[t._v("RxJS 是笔者认为未来几年内会非常红的 Library，RxJS 提供了一套完整的非同步解决方案，让我们在面对各种非同步行为，不管是 Event, AJAX, 还是 Animation 等，我们都可以使用相同的 API (Application Programming Interface) 做开发。")])]),n("p",[n("img",{attrs:{src:"https://raw.githubusercontent.com/Reactive-Extensions/RxJS/master/logos/logo.png",alt:"RxJS Logo"}})]),n("p",[t._v("这是【30天精通 RxJS】的 01 篇，如果还没看过 00 篇可以往这边走：\n"),n("a",{attrs:{href:"https://github.com/ShaofeiZi/30-days-proficient-in-rxjs/blob/master/30%E5%A4%A9%E7%B2%BE%E9%80%9ARXJS%EF%BC%8801%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("30 天精通 RxJS (00)： 关于本系列文章")])]),n("p",[t._v("在网页的世界存取任何资源都是非同步(Async)的，比如说我们希望拿到一个档案，要先发送一个请求，然后必须等到档案回来，再执行对这个档案的操作。这就是一个非同步的行为，而随着网页需求的复杂化，我们所写的 JavaScript 就有各种针对非同步行为的写法，例如使用 callback 或是 Promise 对象甚至是新的语法糖 async/await —— 但随着应用需求愈来愈复杂，撰写非同步的代码仍然非常困难。")]),n("h2",{attrs:{id:"非同步常见的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#非同步常见的问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 非同步常见的问题")]),n("ul",[n("li",[t._v("竞态条件 (Race Condition)")]),n("li",[t._v("内存泄漏 (Memory Leak)")]),n("li",[t._v("复杂的状态 (Complex State)")]),n("li",[t._v("例外处理 (Exception Handling)")])]),n("h3",{attrs:{id:"race-condition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#race-condition","aria-hidden":"true"}},[t._v("#")]),n("a",{attrs:{href:"https://goo.gl/GlNLYl",target:"_blank",rel:"noopener noreferrer"}},[t._v("Race Condition")])]),n("p",[t._v("每当我们对同一个资源同时做多次的非同步存取时，就可能发生 Race Condition 的问题。比如说我们发了一个 Request 更新使用者资料，然后我们又立即发送另一个 Request 取得使用者资料，这时第一个 Request 和第二个 Request 先后顺序就会影响到最终接收到的结果不同，这就是 Race Condition。")]),n("h3",{attrs:{id:"memory-leak"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#memory-leak","aria-hidden":"true"}},[t._v("#")]),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Memory_leak",target:"_blank",rel:"noopener noreferrer"}},[t._v("Memory Leak")])]),n("p",[t._v("Memory Leak 是最常被大家忽略的一点。原因是在传统网站的行为，我们每次换页都是整页重刷，并重新执行 JavaScript，所以不太需要理会内存的问题！但是当我们希望将网站做得像应用程式时，这件事就变得很重要。例如做 "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Single-page_application",target:"_blank",rel:"noopener noreferrer"}},[t._v("SPA")]),t._v(" (Single Page Application) 网站时，我们是透过 JavaScript 来达到切换页面的内容，这时如果有对 DOM 注册监听事件，而没有在适当的时机点把监听的事件移除，就有可能造成 Memory Leak。比如说在 A 页面监听 body 的 scroll 事件，但页面切换时，没有把 scroll 的监听事件移除。")]),n("h3",{attrs:{id:"complex-state"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#complex-state","aria-hidden":"true"}},[t._v("#")]),t._v(" Complex State")]),n("p",[t._v("当有非同步行为时，应用程式的状态就会变得非常复杂！比如说我们有一支付费用户才能播放的视频，首先可能要先抓取这部视频的资讯，接着我们要在播放时去验证使用者是否有权限播放，而使用者也有可能再按下播放后又立即按了取消，而这些都是非同步执行，这时就会各种复杂的状态需要处理。")]),n("h3",{attrs:{id:"exception-handling"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exception-handling","aria-hidden":"true"}},[t._v("#")]),t._v(" Exception Handling")]),n("p",[t._v("JavaScript 的 try/catch 可以捕捉同步的例外，但非同步的程式就没这么容易，尤其当我们的非同步行为很复杂时，这个问题就愈加明显。")]),n("h2",{attrs:{id:"各种不同的-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#各种不同的-api","aria-hidden":"true"}},[t._v("#")]),t._v(" 各种不同的 API")]),n("p",[t._v("我们除了要面对非同步会遇到的各种问题外，还需要烦恼很多不同的 API")]),n("ul",[n("li",[t._v("DOM Events")]),n("li",[t._v("XMLHttpRequest")]),n("li",[t._v("fetch")]),n("li",[t._v("WebSockets")]),n("li",[t._v("Server Send Events")]),n("li",[t._v("Service Worker")]),n("li",[t._v("Node Stream")]),n("li",[t._v("Timer")])]),n("p",[t._v("上面列的 API 都是非同步的，但他们都有各自的 API 及写法！如果我们使用 RxJS，上面所有的 API 都可以透过 RxJS 来处理，就能用同样的 API 操作 (RxJS 的 API)。")]),n("p",[t._v("这里我们举一个例子，假如我们想要监听点击事件(click event)，但点击一次之后不再监听。")]),n("p",[n("strong",[t._v("原生 JavaScript")])]),n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),n("span",{attrs:{class:"token function-variable function"}},[t._v("handler")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tconsole"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("log")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tdocument"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("removeEventListener")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{attrs:{class:"token string"}},[t._v("'click'")]),n("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handler"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{attrs:{class:"token comment"}},[t._v("// 结束监听")]),t._v("\n"),n("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{attrs:{class:"token comment"}},[t._v("// 注册监听")]),t._v("\ndocument"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("addEventListener")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{attrs:{class:"token string"}},[t._v("'click'")]),n("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handler"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),n("p",[n("strong",[t._v("使用 Rx 大概的样子")])]),n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("Rx"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Observable\n\t"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("fromEvent")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("document"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),n("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{attrs:{class:"token string"}},[t._v("'click'")]),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token comment"}},[t._v("// 注册监听")]),t._v("\n\t"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("take")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{attrs:{class:"token number"}},[t._v("1")]),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{attrs:{class:"token comment"}},[t._v("// 只取一次")]),t._v("\n\t"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{attrs:{class:"token function"}},[t._v("subscribe")]),n("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("console"),n("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("log"),n("span",{attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),n("p",[n("a",{attrs:{href:"https://jsbin.com/vofaluv/4/edit?console,output",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSbin")]),t._v(" | "),n("a",{attrs:{href:"https://jsfiddle.net/s6323859/d95a8peo/1/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSFiddle")]),t._v("\n(点击画面后会在 console 显示，记得打开 console 来看)")]),n("p",[t._v("大致上能看得出来我们在使用 RxJS 后，不管是针对 DOM Event 还是上面列的各种 API 我们都可以透过 RxJS 的 API 来做资料操作，像是示例中用 "),n("code",[t._v("take(n)")]),t._v(" 来设定只取一次，之后就释放内存。")]),n("p",[t._v("说了这么多，其实就是简单一句话")]),n("p",[n("strong",[t._v("在面对日益复杂的问题，我们需要一个更好的解决方法。")])]),n("h2",{attrs:{id:"rxjs-基本介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rxjs-基本介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" RxJS 基本介绍")]),n("p",[t._v("RxJS 是一套借由 "),n("strong",[t._v("Observable sequences")]),t._v(" 来组合"),n("strong",[t._v("非同步行为")]),t._v("和"),n("strong",[t._v("事件基础")]),t._v("程序的 Library！")]),n("blockquote",[n("p",[t._v("可以把 RxJS 想成处理 非同步行为 的 Lodash。")])]),n("p",[t._v("这也被称为 Functional Reactive Programming，更切确地说是指 Functional Programming 及 Reactive Programming 两个编程思想的结合。")]),n("blockquote",[n("p",[t._v("RxJS 确实是 Functional Programming 跟 Reactive Programming 的结合，但能不能称为 Functional Reactive Programming (FRP) 一直有争议。")])]),n("blockquote",[n("p",[t._v("Rx 在"),n("a",{attrs:{href:"http://reactivex.io/intro.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网")]),t._v("上特别指出，有时这会被称为 FRP 但这其实是个“误称”。")])]),n("blockquote",[n("p",[t._v("简单说 FRP 是操作随着时间"),n("strong",[t._v("连续性改变的数值")]),t._v(" 而 Rx 则比较像是操作随着时间发出的"),n("strong",[t._v("离散数值")]),t._v("，这个部份读者不用分得太细，因为 FRP 的定义及解释一直存在着歧异，也有众多大神为此争论，如下")])]),n("blockquote",[n("p",[n("a",{attrs:{href:"https://medium.com/@andrestaltz/why-i-cannot-say-frp-but-i-just-did-d5ffaa23973b#.dhmsyic9w",target:"_blank",rel:"noopener noreferrer"}},[t._v("André Staltz")]),t._v("：Rx 著名的推广者，也是 RxJS 5 主要贡献者之一，同时是 Cycle.js 的作者。Staltz 特别写了一篇"),n("a",{attrs:{href:"https://medium.com/@andrestaltz/why-i-cannot-say-frp-but-i-just-did-d5ffaa23973b#.dhmsyic9w",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章")]),t._v("解释为什么 Rx 不能说是 FRP 但他仍然称其为 FRP。")])]),n("blockquote",[n("p",[n("a",{attrs:{href:"https://twitter.com/_juandg",target:"_blank",rel:"noopener noreferrer"}},[t._v("Juan Gomez")]),t._v("：曾在 Netflix 工作，目前任职于 Fitbit，经常出现在国外演讨会，主要写 Android。Juan Gomez 在 "),n("a",{attrs:{href:"https://realm.io/news/droidcon-gomez-functional-reactive-programming/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Droidcon NYC 2015 的演讲")]),t._v("中特别提出他坚持称 Rx 为 FRP。")])]),n("blockquote",[n("p",[n("a",{attrs:{href:"https://twitter.com/czaplic",target:"_blank",rel:"noopener noreferrer"}},[t._v("Evan Czaplicki")]),t._v("：任职于 NoRedInk，Elm 的作者。Evan 在 "),n("a",{attrs:{href:"https://www.youtube.com/watch?v=Agu6jipKfYw",target:"_blank",rel:"noopener noreferrer"}},[t._v("StrangeLoop 2014 的演讲")]),t._v("中，特别为现在各种 FRP 的不同解释做分类。")])]),n("blockquote",[n("p",[t._v("笔者自己的看法是比较偏向直接称 Rx 为 FRP，原因是这较为直觉(FP + RP = FRP)，也比较不会对新手造成困惑，另外就是其他各种编程范式(包含 OOP, FP)其实都是"),n("strong",[t._v("想法的集合，而非严格的指南(Guideline)")]),t._v("，我们应该更宽松的看待 FRP 而不是给他一个严格的定义。")])]),n("h3",{attrs:{id:"关于-reactive-extension-rx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于-reactive-extension-rx","aria-hidden":"true"}},[t._v("#")]),t._v(" 关于 Reactive Extension (Rx)")]),n("p",[t._v("Rx 最早是由微软开发的 LinQ 扩展出来的开源专案，之后主要由社群的工程师贡献，有多种语言支援，也被许多科技公司所采用，如 Netflix, Trello, Github, Airbnb...等。")]),n("h4",{attrs:{id:"rx-的相关资讯"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rx-的相关资讯","aria-hidden":"true"}},[t._v("#")]),t._v(" Rx 的相关资讯")]),n("ul",[n("li",[t._v("开源专案 (Apache 2.0 License)")]),n("li",[t._v("多种语言支持\n"),n("ul",[n("li",[t._v("JavaScript")]),n("li",[t._v("Java")]),n("li",[t._v("C#")]),n("li",[t._v("Python")]),n("li",[t._v("Ruby")]),n("li",[t._v("...(太多了列不完)")])])]),n("li",[n("a",{attrs:{href:"http://reactivex.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网")])]),n("li",[n("s",[t._v("微软目前最成功的开源专案")])])]),n("blockquote",[n("p",[t._v("LinQ 唸做 Link，全名是 Language-Integrated Query，其功能很多元也非常强大；学 RxJS 可以不用会。")])]),n("h3",{attrs:{id:"functional-reactive-programming"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#functional-reactive-programming","aria-hidden":"true"}},[t._v("#")]),t._v(" Functional Reactive Programming")]),n("p",[t._v("Functional Reactive Programming 是一种编程范式(programming paradigm)，白话就是一种"),n("strong",[t._v("写程式的方法论")]),t._v("！举个例子，像 OOP 就是一种编程范式，OOP 告诉我们要使用对象的方式来思考问题，以及撰写程式。而 Functional Reactive Programming 其实涵盖了 Reactive Programming 及 Functional Programming 两种编程思想。")]),n("p",[n("strong",[t._v("Functional Programming")])]),n("p",[t._v("Functional Programming 大部分的人应该多少都有接触过，这也是 Rx 学习过程中的重点之一，我们之后会花两天的篇幅来细讲 Functional Programming。\n如果要用一句话来总结 Functional Programming，那就是 "),n("strong",[t._v("用 function 来思考我们的问题，以及撰写程式")])]),n("blockquote",[n("p",[t._v("在下一篇文章会更深入的讲解 Functional Programming")])]),n("p",[n("strong",[t._v("Reactive Programming")])]),n("blockquote",[n("p",[t._v("很多人一谈到 Reactive Programming 就会直接联想到是在讲 RxJS，但实际上 Reactive Programming 仍是一种编程范式，在不同的场景都有机会遇到，而非只存在于 RxJS，尤雨溪(Vue 的作者)就曾在 twitter 对此表达不满！")])]),n("p",[n("img",{attrs:{src:"https://res.cloudinary.com/dohtkyi84/image/upload/v1480531809/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7_2016-11-30_%E4%B8%8A%E5%8D%886.23.49_zdniva.png",alt:"Evan You 的推文"}})]),n("p",[t._v("Reactive Programming 简单来说就是 "),n("strong",[t._v("当变数或资源发生变动时，由变数或资源自动告诉我发生变动了")])]),n("p",[t._v("这句话看似简单，其实背后隐含两件事")]),n("ul",[n("li",[t._v("当发生变动 => 非同步：不知道什么时候会发生变动，反正变动时要跟我说")]),n("li",[t._v("由变数自动告知我 => 我不用写通知我的每一步代码")])]),n("p",[t._v("由于最近很红的 Vue.js 底层就是用 Reactive Programming 的概念实例，让我能很好的举例，让大家理解什么是 Reactive Programming！")]),n("p",[t._v("当我们在使用 vue 开发时，只要一有绑定的变数发生改变，相关的变数及画面也会跟着变动，而开发者不需要写这其中如何"),n("strong",[t._v("通知")]),t._v("发生变化的每一步代码，只需要"),n("strong",[t._v("专注在发生变化时要做什么事")]),t._v("，这就是典型的 Reactive Programming (记得必须是由变数或资源主动告知！)")]),n("blockquote",[n("p",[t._v("Vue.js 在做 two-ways data binding 是透过 ES5 definedProperty 的 getter/setter。每当变数发生变动时，就会执行 getter/setter 从而收集有改动的变数，这也被称为"),n("strong",[t._v("依赖收集")]),t._v("。")])]),n("p",[t._v("Rx 基本上就是上述的两个观念的结合，这个部份读者在看完之后的文章，会有更深的体悟。")]),n("h2",{attrs:{id:"今日小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#今日小结","aria-hidden":"true"}},[t._v("#")]),t._v(" 今日小结")]),n("p",[t._v("今天这篇文章主要是带大家了解为什么我们需要 RxJS，以及 RxJS 的基本介绍。若读者还不太能吸收本文的内容，可以过一段时间后再回来看这篇文章会有更深的体会，或是在下方留言给我！")])])}],!1,null,null,null);a.default=r.exports}}]);